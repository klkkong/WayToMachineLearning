# DBSCAN
实现DBSCAN算法的C/C++程序。
## 环境
Linux, g++ 4.8.2

## 文件清单
* dbscan.cpp
* dbscanpara.ini

## 算法流程
这是一个对数据集进行聚类的无监督模型。指定邻域和最小颗粒数。对每一个点，如果在邻域范围内存在的颗粒数大于最小颗粒数，那么这个点属于核心点，核心点周围的点是边界点。其他不属于这两类的点为噪音点。核心点依次相连形成聚团。

## 代码说明
1. 读入dbscanpara.ini，给定两个模型参数：skin & minpts。在本程序中skin，颗粒直径为dp，如果两颗粒距离小于(1+skin)dp，则认为两颗粒互为邻居。
2. 数据点来自vtk文件，只读取颗粒的位置信息。
3. Updatebin：为了使用邻居列表加速计算，需要首先将整个区域划分成大小相同的网格。然后统计出每个网格所包含的颗粒编号和颗粒总数。
4. 更新邻居列表：遍历所有颗粒。对每个颗粒，遍历其周围27个网格（三维），按照颗粒间的距离，更新每个颗粒的邻居。
5. DetectCluster：还是遍历所有颗粒。这里用到DFS：找到一个核心点i，把i压入栈，如果i的邻居包含核心点j，那么就把j压入栈。对栈操作，直到栈为空，说明这个聚团就遍历完毕了。
6. 统计每个聚团的回转半径(Cluster->diam)、配位数(Cluster->CooNum，定义是聚团中每个颗粒的邻居数的平均值)、包含的颗粒数(Cluster->size)以及所包含颗粒数的编号(Cluster->idList)
7. 输出结果：CSV文件和vtk文件

## 代码中的bug
1. 这个程序写的比较糟糕，里面一些变量定义但是没用到，全局变量太多，没有统一为结构体，这些都是可以优化的
2. 结构体Cluster中包含vector，需要注意，vector是c++中的对象，而不是内存，所以对Cluster不能使用malloc和memset这些对内存操作的函数。而应该用new。[资料](https://zhidao.baidu.com/question/483251763.html?from=pubpage&msgtype=2)
3. 还有两种可以加速计算的方法：MPI & CUDA，这个可以以后更新。
4. 对于数据集分布不均匀的体系，使用DBSCAN的效果并不好。下图是用skin=2, minpts=5得到的结果。可以看出，在当前的参数下，存在一个超大的聚团。

![cluster.png](https://i.loli.net/2019/05/08/5cd26f238c2a4.png)




